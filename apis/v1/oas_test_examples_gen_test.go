// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAvailabilityEnum_EncodeDecode(t *testing.T) {
	var typ AvailabilityEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AvailabilityEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChangeKeyStatus_EncodeDecode(t *testing.T) {
	var typ ChangeKeyStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChangeKeyStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChangeKeyStatusStatus_EncodeDecode(t *testing.T) {
	var typ ChangeKeyStatusStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChangeKeyStatusStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCloudHSM_EncodeDecode(t *testing.T) {
	var typ CloudHSM
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CloudHSM
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCloudHSMClient_EncodeDecode(t *testing.T) {
	var typ CloudHSMClient
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CloudHSMClient
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCloudHSMLocalRouter_EncodeDecode(t *testing.T) {
	var typ CloudHSMLocalRouter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CloudHSMLocalRouter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCloudHSMPeer_EncodeDecode(t *testing.T) {
	var typ CloudHSMPeer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CloudHSMPeer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCloudHSMPeerList_EncodeDecode(t *testing.T) {
	var typ CloudHSMPeerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CloudHSMPeerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCloudHSMSoftwareLicense_EncodeDecode(t *testing.T) {
	var typ CloudHSMSoftwareLicense
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CloudHSMSoftwareLicense
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCloudHSMSoftwareLicenseServiceClassEnum_EncodeDecode(t *testing.T) {
	var typ CloudHSMSoftwareLicenseServiceClassEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CloudHSMSoftwareLicenseServiceClassEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateCloudHSM_EncodeDecode(t *testing.T) {
	var typ CreateCloudHSM
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateCloudHSM
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateCloudHSMClient_EncodeDecode(t *testing.T) {
	var typ CreateCloudHSMClient
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateCloudHSMClient
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateCloudHSMPeer_EncodeDecode(t *testing.T) {
	var typ CreateCloudHSMPeer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateCloudHSMPeer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateCloudHSMSoftwareLicense_EncodeDecode(t *testing.T) {
	var typ CreateCloudHSMSoftwareLicense
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateCloudHSMSoftwareLicense
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateKey_EncodeDecode(t *testing.T) {
	var typ CreateKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateSecret_EncodeDecode(t *testing.T) {
	var typ CreateSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateVault_EncodeDecode(t *testing.T) {
	var typ CreateVault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateVault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDateTime_EncodeDecode(t *testing.T) {
	var typ DateTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DateTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteSecret_EncodeDecode(t *testing.T) {
	var typ DeleteSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKey_EncodeDecode(t *testing.T) {
	var typ Key
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Key
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyCipher_EncodeDecode(t *testing.T) {
	var typ KeyCipher
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyCipher
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyEncryptAlgoEnum_EncodeDecode(t *testing.T) {
	var typ KeyEncryptAlgoEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyEncryptAlgoEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyOriginEnum_EncodeDecode(t *testing.T) {
	var typ KeyOriginEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyOriginEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyPlain_EncodeDecode(t *testing.T) {
	var typ KeyPlain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyPlain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyServiceClassEnum_EncodeDecode(t *testing.T) {
	var typ KeyServiceClassEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyServiceClassEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyStatusEnum_EncodeDecode(t *testing.T) {
	var typ KeyStatusEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyStatusEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedCloudHSMClientList_EncodeDecode(t *testing.T) {
	var typ PaginatedCloudHSMClientList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedCloudHSMClientList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedCloudHSMList_EncodeDecode(t *testing.T) {
	var typ PaginatedCloudHSMList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedCloudHSMList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedCloudHSMSoftwareLicenseList_EncodeDecode(t *testing.T) {
	var typ PaginatedCloudHSMSoftwareLicenseList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedCloudHSMSoftwareLicenseList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedKeyList_EncodeDecode(t *testing.T) {
	var typ PaginatedKeyList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedKeyList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedSecretList_EncodeDecode(t *testing.T) {
	var typ PaginatedSecretList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedSecretList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaginatedVaultList_EncodeDecode(t *testing.T) {
	var typ PaginatedVaultList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaginatedVaultList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScheduleDestructionKey_EncodeDecode(t *testing.T) {
	var typ ScheduleDestructionKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScheduleDestructionKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSecret_EncodeDecode(t *testing.T) {
	var typ Secret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Secret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServiceClassEnum_EncodeDecode(t *testing.T) {
	var typ ServiceClassEnum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceClassEnum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnvail_EncodeDecode(t *testing.T) {
	var typ Unvail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Unvail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVault_EncodeDecode(t *testing.T) {
	var typ Vault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Vault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedChangeKeyStatus_EncodeDecode(t *testing.T) {
	var typ WrappedChangeKeyStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedChangeKeyStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCloudHSM_EncodeDecode(t *testing.T) {
	var typ WrappedCloudHSM
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCloudHSM
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCloudHSMClient_EncodeDecode(t *testing.T) {
	var typ WrappedCloudHSMClient
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCloudHSMClient
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCloudHSMPeer_EncodeDecode(t *testing.T) {
	var typ WrappedCloudHSMPeer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCloudHSMPeer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCloudHSMSoftwareLicense_EncodeDecode(t *testing.T) {
	var typ WrappedCloudHSMSoftwareLicense
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCloudHSMSoftwareLicense
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateCloudHSM_EncodeDecode(t *testing.T) {
	var typ WrappedCreateCloudHSM
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateCloudHSM
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateCloudHSMClient_EncodeDecode(t *testing.T) {
	var typ WrappedCreateCloudHSMClient
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateCloudHSMClient
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateCloudHSMPeer_EncodeDecode(t *testing.T) {
	var typ WrappedCreateCloudHSMPeer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateCloudHSMPeer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateCloudHSMSoftwareLicense_EncodeDecode(t *testing.T) {
	var typ WrappedCreateCloudHSMSoftwareLicense
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateCloudHSMSoftwareLicense
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateKey_EncodeDecode(t *testing.T) {
	var typ WrappedCreateKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateSecret_EncodeDecode(t *testing.T) {
	var typ WrappedCreateSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedCreateVault_EncodeDecode(t *testing.T) {
	var typ WrappedCreateVault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedCreateVault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedDeleteSecret_EncodeDecode(t *testing.T) {
	var typ WrappedDeleteSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedDeleteSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedKey_EncodeDecode(t *testing.T) {
	var typ WrappedKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedKeyCipher_EncodeDecode(t *testing.T) {
	var typ WrappedKeyCipher
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedKeyCipher
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedKeyPlain_EncodeDecode(t *testing.T) {
	var typ WrappedKeyPlain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedKeyPlain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedScheduleDestructionKey_EncodeDecode(t *testing.T) {
	var typ WrappedScheduleDestructionKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedScheduleDestructionKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedUnvail_EncodeDecode(t *testing.T) {
	var typ WrappedUnvail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedUnvail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWrappedVault_EncodeDecode(t *testing.T) {
	var typ WrappedVault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WrappedVault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
